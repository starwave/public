//
//  DeviceInfoManager.swift
//  WallpaperInfoApp
//
//  Created by Brad Park on 4/12/20.
//  Copyright Â© 2020 Brad Park. All rights reserved.
//

import Foundation
import Cocoa
import IOKit
import IOKit.usb
import IOKit.hid
import IOKit.network

extension NSObject {
    var theClassName: String {
        return NSStringFromClass(type(of: self))
    }
}

class PlatformInfo {
	
	static private func createDeviceMatchingDictionary( usagePage: Int, usage: Int) -> CFMutableDictionary {
		let dict = [
			kIOHIDDeviceUsageKey: usage,
			kIOHIDDeviceUsagePageKey: usagePage
			] as NSDictionary
		return dict.mutableCopy() as! NSMutableDictionary
	}
	
	static func bluetoothRemoteExists() -> Bool {
		struct Cache {
			static var lastCheckTime: Date = Date(dateString: "1970-01-01")
			static var lastResult:Bool = false
		}
		if (Date().getDiffInSecond(since: Cache.lastCheckTime) < 10) {
			print("bluetoothRemoteExists = ", Cache.lastResult)
			return Cache.lastResult
		}
		Cache.lastCheckTime = Date()
        Cache.lastResult = false
        // if os is El Capitan, there is IR remote, Quick Hack to support sahara-mac
        //if #available(OSX 10.11, *) {
            //Cache.lastResult = true
            //return Cache.lastResult
        //}
		let manager = IOHIDManagerCreate(kCFAllocatorDefault, IOOptionBits(kIOHIDOptionsTypeNone));
		let keyboard = createDeviceMatchingDictionary(usagePage: kHIDPage_GenericDesktop, usage: kHIDUsage_GD_Keyboard)
		IOHIDManagerOpen(manager, IOOptionBits(kIOHIDOptionsTypeNone) )
		IOHIDManagerSetDeviceMatching(manager, keyboard)
		if let devices = IOHIDManagerCopyDevices(manager) {
			if let deviceSet = devices as? Set<IOHIDDevice> {
				for device in deviceSet {
					let deviceClassName = String(describing: device.self)
					print(deviceClassName)
					if (deviceClassName.contains("Transport=Bluetooth")) {
						Cache.lastResult = true
					}
				}
			}
		}
		print("bluetoothRemoteExists = ", Cache.lastResult)
		return Cache.lastResult
	}
    
    static func getTemporaryDirectory() -> String {
        return NSTemporaryDirectory()
    }
    
    static func getDockHeight(screen: NSScreen) -> CGFloat {
        let visibleFrame = screen.visibleFrame
        let screenFrame = screen.frame;

        if (visibleFrame.origin.x > screenFrame.origin.x) {
            BPUtil.BPLog(screen.description + ": Dock is positioned on the LEFT")
        } else if (visibleFrame.origin.y > screenFrame.origin.y) {
            BPUtil.BPLog(screen.description + ": Dock is positioned on the BOTTOM")
            return visibleFrame.origin.y - screenFrame.origin.y
        } else if (visibleFrame.size.width < screenFrame.size.width) {
            BPUtil.BPLog(screen.description + ": Dock is positioned on the RIGHT")
        } else {
            BPUtil.BPLog(screen.description + ": Dock is HIDDEN")
        }
        return 0
    }
    
	// delete wallpaper cache files generated by OS X
	static func cleanWallpaperCache() {
		struct PlatformCacheInfo {
			static var lockscreenPath = ""
			static var wallpaperPath = ""
		}
        BPUtil.BPLog("cleanWallpaperCache begin")
		// get the platform search path the first to avoid find command hang due to permission check without it.
		if (PlatformCacheInfo.lockscreenPath == "") {
			let task = "find /var/folders \\( -name '*-lockscreen.png' -o -name '*-com.apple.desktop.admin.png' \\) -type f -print -quit 2> /dev/null"
			let lockscreenFile = task.bashCommand();
			PlatformCacheInfo.lockscreenPath = URL(fileURLWithPath: lockscreenFile).deletingLastPathComponent().path
			if (!PlatformCacheInfo.lockscreenPath.hasPrefix("/var/folders")) {
				PlatformCacheInfo.lockscreenPath = "/var/folders"
				PlatformCacheInfo.wallpaperPath = "/invalid"
			} else {
				let task = "find /var/folders -name '*com.apple.desktoppicture*' -type d -print -quit 2> /dev/null"
				PlatformCacheInfo.wallpaperPath = task.bashCommand().trimmingCharacters(in: .whitespacesAndNewlines)
				if (!PlatformCacheInfo.wallpaperPath.hasPrefix("/var/folders")) {
					PlatformCacheInfo.wallpaperPath = "/invalid"
				}
			}
		}
		let task = "find " + PlatformCacheInfo.lockscreenPath + " " + PlatformCacheInfo.wallpaperPath + " -name '*.png' -mmin +5 -type f -exec rm -fv {} \\; 2> /dev/null"
		let _ = task.bashCommand()
	}
    
    class func swiftprintf(_ format: String, _ arguments: CVarArg... ) -> String? {
        return withVaList(arguments) { va_list in
            var buffer: UnsafeMutablePointer<Int8>? = nil
            return format.withCString { cString in
                guard vasprintf(&buffer, cString, va_list) != 0 else {
                    return nil
                }
                return String(validatingUTF8: buffer!)
            }
        }
    }
}

extension DispatchQueue {
    static func background(delay: Double = 0.0, background: (()->Void)? = nil, completion: (() -> Void)? = nil) {
        DispatchQueue.global(qos: .background).async {
            background?()
            if let completion = completion {
                DispatchQueue.main.asyncAfter(deadline: .now() + delay, execute: {
                    completion()
                })
            }
        }
    }
}

/**
Makes sure no other thread reenters the closure before the one running has not returned
*/
@discardableResult
public func synchronized<T>(_ lock: AnyObject, closure:() -> T) -> T {
    objc_sync_enter(lock)
    defer { objc_sync_exit(lock) }

    return closure()
}

extension Date {
    func getDiffInSecond(since date: Date) -> Int  {
        let calendar = Calendar.current
        let dateComponents = calendar.dateComponents([Calendar.Component.second], from: date, to: self)
        let seconds = dateComponents.second
        return Int(seconds!)
    }
    init(dateString: String) {
        let dateStringFormatter = DateFormatter()
        dateStringFormatter.dateFormat = "yyyy-MM-dd"
        if let d = dateStringFormatter.date(from: dateString) {
            self.init(timeInterval: 0, since: d)
        } else {
            let defaultdate = dateStringFormatter.date(from: "1971-10-01")
            self.init(timeInterval: 0, since: defaultdate!)
        }
    }
}

// example to use the above
/*
let returnedValue = synchronized(self) {
     // Your code here
     return yourCode()
}

synchronized(self) {
     // Your code here
    yourCode()
}
*/

/* Legacy Code for Screen information

init(observer:NSObject, callback: @escaping (() -> Void)) {
	_screenChangeObserver = observer
	_screenChangeSelector = callback
	updateDisplayDictionary()
}

private func updateDisplayDictionary() {
	_displayDic = NSMutableDictionary()
	let screens:[NSScreen] = NSScreen.screens
	for screen:NSScreen in screens {
		let screenDic:NSDictionary = screen.deviceDescription as NSDictionary
		let screenNumber:String = String(screenDic["NSScreenNumber"] as! Int)
		let displayUUID:String = getUUIDfromScreenNumber(screenNumber: screenNumber)
		_displayDic?.setValue(displayUUID, forKey: screenNumber)
		_screenNumbers?.add(screenNumber)
	}
}

private func didChangeScreenParameters() {
	updateDisplayDictionary()
}

private func getUUIDfromScreenNumber(screenNumber: String) -> String {
	
	/*
	 NSString *uuidStr = @"";
	 
	 CGDirectDisplayID displayID = (CGDirectDisplayID)strtoull([screenNumber UTF8String], NULL, 0);
	 CFUUIDRef uuid = CGDisplayCreateUUIDFromDisplayID(displayID);
	 if (CFGetTypeID(uuid) != CFNullGetTypeID()) {
		 uuidStr = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	 }
	 CFRelease(uuid);
		 
	 return uuidStr;
	 */
	
	return ""
}

private func screenNameForIndex(screenIndex: Int) -> String {
	
	/*
	NSString *screenName = nil;
	
	CGDirectDisplayID displayID = (CGDirectDisplayID)strtoull([[_screenNumbers objectAtIndex:screenIndex] UTF8String], NULL, 0);
	NSDictionary *deviceInfo = CFBridgingRelease(IODisplayCreateInfoDictionary(CGDisplayIOServicePort(displayID), kIODisplayOnlyPreferredName));
	NSDictionary *localizedNames = [deviceInfo objectForKey:[NSString stringWithUTF8String:kDisplayProductName]];
	
	if ([localizedNames count] > 0) {
		screenName = [[localizedNames objectForKey:[[localizedNames allKeys] objectAtIndex:0]] retain];
	}
	
	return [screenName autorelease];
	*/
	
	return ""
}

var _displayDic: NSMutableDictionary?
var _screenNumbers: NSMutableArray?
var _screenChangeObserver: NSObject?
var _screenChangeSelector:(() -> Void)?

*/
